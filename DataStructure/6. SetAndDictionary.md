## 第六章 集合与字典

1. 当集合是全集合{0,1,2,3,..,n}的一个子集，且n是不大的整数或者由有限的可枚举的成员组成时，可以用0,1 向量来实现集合

   ```c++
   //求并
   bitVector<i> || other<j>;
   //求差，A中有，B中没有
   bitVector<i> && !other<j>
   //求交
   bitVector<i> && other<j>    
   ```

2. 并查集除了用数组构建树状机构构建等价类之外，还可以使用**无向图**来表示，求等价类只需要求**联通分量**即可

   - 压缩路径算法：

   ```c++
   int CollapsingFind(int set[],int n,int i){
       int j=i;
       for(;set[j]>0=;j=set[j]);
       while(set[i]!=j){
           int temp=set[i];
           set[i]=j;
           i=temp;
       }
   }
   ```

3. 字典中衡量一个搜素算法的标准：**ASL(Average Success Length)**

   - $ASL=\sum_{i=0}^{n-1}p_i*c_i,\sum_{i=0}^{n-1}p_i=1$

4. 对于有序顺序表作为底层结构的字典，可以使用折半查找法进行搜索

5. 散列函数的选取：

   - 直接定址法
   - 除留余数法：设散列中允许的地址数为m，取一个不大于m，但最接近或等于m的质数p作为除数，利用以下函数把关键码转换成散列地址：$hash(key)=key\%p\ ,\ p\le m$

6. 应用开散列法处理冲突，需要增设链接指针，似乎增加了存储开销，但事实上，由于闭散列法**必须保持大量的空闲空间以确保搜索效率**，而表项所占空间又比指针大得多，所以使用开散列法反而比闭散列法节省存取空间