## 第三章 栈和队列

1. 栈允许插入和删除的一端称为栈顶，另一端称为栈底

2. 十进制转换为其他进制用栈实现：

   ```c++
   int main()
   {
   	stack<int> ans;
   	//十进制数
   	int n=15;
   	//k进制
   	int k=2;
   	while (n > 0) {
   		int temp = n % k;
   		ans.push(temp);
   		n = n / k;
   	}
   	while (!ans.empty()) {
   		cout << ans.top();
   		ans.pop();
   	}
   	cout << endl;
   }
   ```

3. 用后缀表达式进行计算：

   - 若该项是操作数，则将其压栈
   - 如果该项式操作符<op\>，则从栈中连续取出两个操作数Y和X，形成运算指令 X<op\> Y，并将计算结果重新压栈
   - 表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果

   P.S. 如果是前缀表达式那么从后向前遍历，其余的操作不变

4. 从**中缀表达式生成后缀表达式**：

   - 遇见数字直接输出
   - 如果栈顶为空，那么当作栈顶符号优先级为最小

   - 当碰到一个运算符号的时候和栈顶的运算符号做比较，如果栈顶的运算符号优先级比它**不小于它**(优先级相同的时候先算左边的)，就可以将栈顶运算符拿出来进行运算，然后再接着和栈顶符号做比较
   - 如果栈顶符号优先级比它低，那么就把自己压栈
   - 当遍历完如果栈中还有符号，那么逐个弹出即可
   - **优先级**：队列**外左括**号的优先级最高，队列内**左括号**的优先级最低，其他的运算符队列内外优先级相同，右括号优先级最低

5. 斐波那契数列的调用递归函数的时间复杂度为 $2Fib(n)-1$，算法的时间复杂度为 $O(2^n)$，空间复杂度也也是 $O(2^n) $

6. 单向递归和尾递归可以用迭代法实现

7. 循环队列：

   ```C++
   //用数组
   //初始化
   rear=front=0;
   //进队
   rear=(rear+1)%len;
   q[rear]=x;
   //出队
   ans=q[front];
   front=(front+1)%len;
   //队空
   rear==front;
   //队满
   (rear+1)%len==front;
   ```

8. 用队列打印杨辉三角：

   ```c++
   int main(){
   	queue<int> q;
   	q.push(1);
   	q.push(1);
   	int n=10;
   	for (int i = 1; i <=n; i++) {
   		q.push(1);
   		for (int j = 1; j <=i + 1; j++) {
   			int ans1 = q.front();
   			q.pop();
   			cout << ans1 << " ";
   			if (j != i + 1) {
   				int ans2 = q.front();
   				q.push(ans1 + ans2);
   			}
   		}
   		q.push(1);
   		cout << endl;
   	}
   }
   ```

   





